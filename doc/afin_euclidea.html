<!doctype html>
<html>
<head>
<title>afin_euclidea</title>
<meta charset='utf-8'><link rel='stylesheet' type='text/css' href='style.css'>
</head>
<body>
<a href='index.html'>Página principal</a><h1>afin_euclidea</h1>
<p>
Archivo con clases representantes de espacios tanto afines como euclídeos con diversas funciones relacionadas con aplicaciones, cónicas, etc. <br>
Autor: Pablo Sanz Sanz <br>
</p>
<div class='class'>
<h2>Clase: espacio_afin</h2>
<p>
Clase que representa un espacio afín de una dimensión arbitraria. Sirve para diversos cálculos relacionados con subespacios, cónicas, etc. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye un espacio afín, dado el hiperplano del infinito. <br>
Parámetros <br>
hiperplano_infinito: subespacio(dim=n-1) - hiperplano que se está considerando como infinito (xn = 0 por defecto) <br>
dimension: natural - dimensión de este espacio si no se han especificado los dos anteriores parámetros; por ejemplo, espacio_afin(dimension = 2) crea un espacio afín cuya recta del infinto es z = 0 y la referencia es la canónica (2 por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: dim()</h3>
<p>
Devuelve la dimensión de este espacio afín. </p>
</div>
<div class='function'>
<h3>Función: hiperplano_infinito()</h3>
<p>
Devuelve el hiperplano del infinito de este espacio afín en la referencia en que está expresado el espacio. </p>
</div>
<div class='function'>
<h3>Función: es_referencia_valida(referencia)</h3>
<p>
Determina si la referencia indicada es válida para es espacio, esto es, todos los vectores son de longitud adecuada, son suficientes y todos menos el último son proyectivamente independientes. <br>
Parámetros <br>
referencia: lista(vector(n+1))(long=n+2) - referencia a comprobar <br>
</p>
</div>
<div class='function'>
<h3>Función: es_referencia_afin(referencia)</h3>
<p>
Determina si la referencia indicada es una referencia afín, esto es, cada punto de los n primeros pertenece al hiperplano del infinito. <br>
Parámetros <br>
referencia: lista(vector(n+1))(long=n+2) - referencia a comprobar <br>
</p>
</div>
<div class='function'>
<h3>Función: cambiar_referencia(matriz_cambio)</h3>
<p>
Devuelve un nuevo espacio afín (no modifica este) que se supone expresado en una referencia R' dada la matriz del cambio de la referencia canónica a R'. <br>
Implementación <br>
Cambia la referencia del hiperplano del infinito usando M^-t * u, donde u es el vector asociado a las coordenadas de H (el vector dual al subespacio). <br>
Parámetros <br>
matriz_cambio: matriz(n+1,n+1) - matriz del cambio de referencia a R' <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_infinitos(s)</h3>
<p>
Determina los puntos del infinito del subespacio dado, esto es la intersección de este con el hiperplano del infinito. Devuelve un objeto del tipo subespacio. Si el subespacio dado es una recta se puede tomar el único punto de intersección con el método punto() de la clase subespacio. <br>
Parámetros <br>
s: subespacio(dim_ambiente=n) - subespacio del que se quiere conocer los puntos del infinito <br>
</p>
</div>
<div class='function'>
<h3>Función: direccion(r)</h3>
<p>
Devuelve la dirección de la recta indicada, esto es, su corte con la recta del infinito. <br>
Parámetros <br>
r: subespacio(dim=1,dim_amb=n) - recta de la que calcular su dirección <br>
</p>
</div>
<div class='function'>
<h3>Función: paralelos(r, s)</h3>
<p>
Determina si dos subespacios son paralelos, esto es, si la intersección con el hiperplano del infinito de uno esá contenida (o es igual) en la del otro. <br>
Parámetros <br>
r: subespacio(dim_ambiente=n) - uno de los subespacios que se quiere comprobar si son paralelos <br>
s: subespacio(dim_ambiente=n) - el otro <br>
</p>
</div>
<div class='function'>
<h3>Función: paralela(r, p)</h3>
<p>
Calcula la recta paralela la recta r que pasa por el punto P. <br>
Implementación <br>
Calcula el punto del infinito de la recta y lo une con P. <br>
Parámetros <br>
r: subespacio(dim=1,dim_amb=n) - recta de la que obtener la paralela <br>
p: vector(m+1) - punto por el que debe pasar la paralela <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_simple(a, b, c)</h3>
<p>
Calcula la razón simple (A, B, C) de los puntos alineados dados. <br>
Implementación <br>
Calcula la razón doble {Pinf, A; B, C}, donde Pinf es el punto de intersección entre la recta que forman los puntos y el hiperplano del infinito (ver razon_doble (recta_proyectiva.sage)). <br>
Parámetros <br>
a: vector(n+1) - primer punto de la razón simple <br>
b: vector(n+1) - segundo punto de la razón simple <br>
c: vector(n+1) - tercer punto de la razón simple <br>
</p>
</div>
<div class='function'>
<h3>Función: desplazar(p, a, b)</h3>
<p>
Devuelve el punto que se obtiene al desplazar el punto P dado en la dirección del vector AB y distancia |AB|. <br>
Implementación <br>
Calcula la recta paralela desde P al vector AB y halla la intersección con la paralela a PA desde B. <br>
Parámetros <br>
p: vector(n+1) - punto a desplazar <br>
a: vector(n+1) - punto de origen del vector <br>
b: vector(n+1) - punto de destino del vector <br>
</p>
</div>
<div class='function'>
<h3>Función: son_simetricos(p1, p2, centro)</h3>
<p>
Determina si los puntos dados son simétricos respecto del centro dado. Para ello deben yacer todos en la misma recta. <br>
Implementación <br>
Determina si {P1, P2 ; C, Pinf} es una cuaterna armónica, donde Pinf es el punto de intersección entre la recta que forman los puntos y el hiperplano del infinito (ver es_cuaterna_armonica (recta_proyectiva.sage)). <br>
</p>
</div>
<div class='function'>
<h3>Función: simetrico(punto, centro)</h3>
<p>
Calcula el punto simétrico a un punto respecto de un punto "centro" de la simetría. El punto calculado estará en la recta que forman los puntos dados. <br>
Implementación <br>
Monta la recta (ver recta_proyectiva (recta_proyectiva.sage)) que pasa por los puntos, tomando como referencia {Pinf, C; P}, donde Pinf es el punto del infinito de la recta PC y C el centro dado. Entonces, el simétrico de P será aquel cuya coordenada sea la opuesta a la de P, esto es, el punto de coordenada -1. <br>
Parámetros <br>
punto: vector(n+1) - punto del que se quiere calcular su simétrico <br>
centro: vector(n+1) - punto centro de la simetría <br>
</p>
</div>
<div class='function'>
<h3>Función: punto_medio(p1, p2)</h3>
<p>
Calcula el punto medio entre p1 y p2. Es lo contrario al método simetrico. <br>
Implementación <br>
Calcula el conjugado armónico de Pinf respecto de P1 y P2, donde Pinf es el punto del infinito de la recta P1P2 (ver conjugado_armonico (recta_proyectiva.sage)). <br>
Parámetros <br>
p1: vector(n+1) - uno de los puntos de los que se quiere calcular el punto medio <br>
p2: vector(n+1) - el otro punto <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_infinitos_conica(c)</h3>
<p>
Devuelve los dos puntos de intersección de la recta del infinito con la cónica dada. <br>
Parámetros <br>
c: conica/parametrizacion_conica - cónica a intersecar <br>
</p>
</div>
<div class='function'>
<h3>Función: clasificacion_conica(c)</h3>
<p>
Devuelve una cadena de texto que indica el tipo de la cónica dada por parámetro. No se diferencian casos reales de imaginarios (p.e: elipse real o imaginaria). <br>
Implementación <br>
Calcula la intersección de la cónica con la recta del infinito y se pueden dar los siguientes casos: <br>
· Intersección en dos puntos reales: hipérbola. <br>
· Intersección en dos puntos complejos: elipse <br>
· Intersección en un punto doble: parábola <br>
Parámetros <br>
c: conica/parametrizacion_conica - cónica a clasificar <br>
</p>
</div>
<div class='function'>
<h3>Función: centro_conica(c)</h3>
<p>
Devuelve el centro de la cónica dada, esto es, el polo de la recta del infinito. Si la cónica es una parábola no tendrá centro y devolverá un vector vacío. <br>
Parámetros <br>
c: conica - cónica de la que se quiere saber el centro <br>
</p>
</div>
<div class='function'>
<h3>Función: asintotas_conica(c)</h3>
<p>
Devuelve una tupla conteniendo las asíntotas de la cónica dada. Nótese que en caso de ser una elipse estas serán rectas imaginarias y en caso de ser una parábola no tendrá (pues no tiene centro) y se devolverán dos subespacios vacíos. <br>
Implementación <br>
Las asíntotas son tangentes a la cónica en la recta del infinito. Se calcula la intersección con ella y el resultado serán las tangentes (las polares) de cada punto. <br>
Parámetros <br>
c: conica - cónica de la que obtener las asíntotas <br>
</p>
</div>
<div class='function'>
<h3>Función: referencia_ecuacion_reducida(c, diam = None, x2 = None, e = None, real = True)</h3>
<p>
Devuelve una lista con los vectores de la referencia afín en que la cónica dada tendrá ecuación reducid x^2 +/- y^2 +/- z^2 = 0. <br>
NOTA. Cuidado de no usar asíntotas como diámetro en el parámetro, pues son tangentes a la cónica. <br>
Implementación <br>
Si la cónica tiene centro, se toma como origen de coordenadas, esto es, X2 = C. Los otros dos puntos, X0 y X1, se toman como los puntos del infinito de dos diámetros conjugados cualesquiera (se debe indicar uno de ellos como parámetro). <br>
En el caso de la parábola se tomará como origen un punto de la cónica del que se podrá indicar su coordenada x (z será 1 por defecto). Se tomarán, además, X0 el punto de tangencia con la recta del infinito y el polo de X0X2 como X1. <br>
El punto unidad será escogido en ambos casos por el método referencia_autopolar de la cónica (conica (cuadricas.sage)). <br>
Parámetros <br>
c: conica - cónica de la que obtener la referencia en la que tiene ecuación reducida <br>
diam: subespacio(dim=1,dim_amb=2) - diámetro que se quiera usar para el primer caso (por defecto ninguno) <br>
x2: vector(3) - tercer punto que se quiera tomar en la referencia en el segundo caso (por defecto ninguno) <br>
e: vector(3) - punto unidad que se quiera tomar en la referencia en el segundo caso (por defecto ninguno) <br>
real: booleano - determina si la cónica debe ser necesariamente real o no (True por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: es_diametro(c, d)</h3>
<p>
Determina si una recta d dada como subespacio es un diámetro de la cónica indicada, es decir, si pasa por su centro. <br>
Parámetros <br>
c: conica - cónica de la que se quiere saber si d es diámetro <br>
d: subespacio(dim=1,dim_amb=2) - recta candidata a ser diámetro <br>
</p>
</div>
<div class='function'>
<h3>Función: diametro_conjugado(c, d)</h3>
<p>
Calcula el diámetro conjugado del dado respecto de la conica indicada. <br>
Implementación <br>
Obtiene la recta polar del punto del infinito del diámetro respecto de la cónica. <br>
Parámetros <br>
c: conica - cónica sobre la que se quiere calcular el diámetro conjugado <br>
d: subespacio(dim=1,dim_amb=2) - diámetro del que se quiere calcular su conjugado <br>
</p>
</div>
<div class='function'>
<h3>Función: son_diametros_conjugados(c, d1, d2)</h3>
<p>
Determina si los diámetros d1 y d2 son conjugados respecto a la cónica c. Esto ocurre cuando sus puntos del infinito son conjugados respecto a c, o lo que es lo mismo, que la polar del punto del infinito de uno sea el otro diámetro. <br>
Parámetros <br>
c: conica - cónica de la que se quiere saber si los diámetros son conjugados <br>
d1: subespacio(dim=1,dim_amb=2) - primer diámetro <br>
d2: subespacio(dim=1,dim_amb=2) - segundo diámetro <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: espacio_euclideo</h2>
<p>
Clase que representa un espacio euclídeo de dimensión 2. Sirve para diversos cálculos relacionados con subespacios, cónicas, etc. No utiliza la cuádrica del absoluto, pero sí los puntos conjugados del infinito. <br>
IMPORTANTE. Cuidado de no llamar a ninguna variable I por ningún lugar o probablemente esto deje de funcionar. <br>
NOTA. Esta clase está basada en espacio_afin, pero no me he molestado en aprender herencia en Python, así que, si se quieren usar métodos de espacio_afin, se deberá acceder al que esta clase proporciona mediante el método espacio_afin(). <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye un espacio euclídeo dado uno de sus puntos conjugados del infinito. <br>
Parámetros <br>
i: vector(3)(imaginario) - uno de los puntos cíclicos conjugados del infinito, del que se obtiene la recta del infinito ((1 : i : 0) por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: espacio_afin()</h3>
<p>
Devuelve el espacio afín asociado a este espacio euclídeo. </p>
</div>
<div class='function'>
<h3>Función: recta_infinito()</h3>
<p>
Devuelve la recta del infinito de este espacio euclídeo. </p>
</div>
<div class='function'>
<h3>Función: conjugados_infinito()</h3>
<p>
Devuelve una tupla conteniendo los puntos conjugados del infinito. </p>
</div>
<div class='function'>
<h3>Función: I()</h3>
<p>
Devuelve el primer punto conjugado del infinito. </p>
</div>
<div class='function'>
<h3>Función: J()</h3>
<p>
Devuelve el segundo punto conjugado del infinito. </p>
</div>
<div class='function'>
<h3>Función: cambiar_referencia(matriz_cambio)</h3>
<p>
Devuelve un nuevo espacio euclídeo (no modifica este) que se supone expresado en una referencia R' dada la matriz del cambio de la referencia canónica a R'. <br>
Implementación <br>
Cambia la referencia del espacio afín asociado a este y las coordenadas de los puntos conjugados del infinito. <br>
Parámetros <br>
matriz_cambio: matriz(3,3) - matriz del cambio de referencia a R' <br>
</p>
</div>
<div class='function'>
<h3>Función: perpendiculares(u, v)</h3>
<p>
Determina si las direcciones son ortogonales. <br>
Para determinar si lo son dos rectas, primero calcular su dirección. <br>
Implementación <br>
Determina si los puntos forman una cuaterna armónica con los puntos conjugados del infinito. <br>
u: vector(3) - uno de los puntos del infinito de los que se quiere saber si son perpendiculares <br>
v: vector(3) - el otro <br>
</p>
</div>
<div class='function'>
<h3>Función: direccion_perpendicular(u)</h3>
<p>
Determina la dirección perpendicular a la dada. <br>
Implementación <br>
Calcula el cuarto armónico de u respecto de los puntos conjugados del infinito. <br>
Parámetros <br>
u: vector(3) - el punto del infinito del que se quiere saber su perpendicular <br>
</p>
</div>
<div class='function'>
<h3>Función: perpendicular(u, p)</h3>
<p>
Determina la recta perpendicular a la dada que pasa por el punto P dado. <br>
Implementación <br>
Calcula la dirección perpendicular y une con P. <br>
Parámetros <br>
u: vector(3) - el punto del infinito del que se quiere saber su perpendicular <br>
p: vector(3) - punto por el que debe pasar la perpendicular calculada <br>
</p>
</div>
<div class='function'>
<h3>Función: angulo(u, v)</h3>
<p>
Calcula el ángulo entre dos direcciones. <br>
Para calcularlo para rectas, calcular su dirección primero. <br>
Implementación <br>
Calcula 1/2i * Log{u, v; I, J} <br>
u: vector(3) - uno de los puntos del infinito de los que se quiere saber si son perpendiculares <br>
v: vector(3) - el otro <br>
</p>
</div>
<div class='function'>
<h3>Función: es_circunferencia(c)</h3>
<p>
Determina si la cónica C dada es una circunferencia, esto es, si contiene los puntos conjugados del infinito. <br>
Parámetros <br>
c: conica/parametrizacion_conica - conica a comprobar si es una circunferencia <br>
</p>
</div>
<div class='function'>
<h3>Función: focos(c)</h3>
<p>
Devuelve una lista contieniendo los focos de la cónica dada. <br>
NOTA. Puede ser un poco lento. Paciencia. <br>
IMPORTANTE. No es fiable 100% cuando depende de la factorización de cónicas degeneradas, pues no es un método fiable 100%. Si se obtienen resultados muy raros o errores es recomendable ejecutar varias veces. Si eso no lo arregla, tocará hacerlo a mano (seguir la implementación que se da más abajo, pero hallando las rectas tangentes a mano). <br>
Implementación <br>
Se obtienen las cónicas degeneradas tangentes a c desde I y J y se obtienen los puntos de corte F, F', G y G', donde G, G' son los focos imaginarios. En caso de ser una circunferencia, únicamente devuelve su centro. <br>
Parámetros <br>
c: conica - cónica de la que calcular los focos <br>
</p>
</div>
<div class='function'>
<h3>Función: ejes(c, x = None)</h3>
<p>
Devuelve una tupla con los ejes de la cónica dada. Para una cónica con cuatro focos, simplemente une los focos reales entre sí (y lo mismo para los imaginarios). Para las cónicas con un solo foco, lo une con el "centro" infinito en el caso de la parábola y con el x dado por parámetro en el caso de la circunferencia, pues el foco coincide con el centro (el otro eje es su perpendicular). <br>
IMPORTANTE. En el caso de la parábola el segundo eje que se devuelve no es un eje real, sino la recta del infinito. <br>
IMPORTANTE 2. No es fiable 100% cuando depende de la factorización de cónicas degeneradas, pues no es un método fiable 100%. Si se obtienen resultados muy raros o errores es recomendable ejecutar varias veces. Si eso no lo arregla, tocará calcular los focos a mano. <br>
NOTA. No se muestra el procedimiento de calcular los focos. <br>
Parámetros <br>
c: conica - cónica de la que obtener sus ejes <br>
x: vector(3) - dirección (punto de la recta del infinito) desde la que calcular el prumer eje en el caso de la circunferencia (por defecto ninguno, pues en general no es necesario) <br>
</p>
</div>
<div class='function'>
<h3>Función: directrices(c)</h3>
<p>
Devuelve una lista con las directrices de la cónica indicada, esto es, las polares de los focos. Deberían ser rectas reales o, en caso de ser imaginarias, simplificables. En el caso de que la cónica sea una circunferencia, su directriz será la propia recta del infinito, luego no una recta del plano. Igualmente se devuelve el resultado. <br>
IMPORTANTE. No es fiable 100% cuando depende de la factorización de cónicas degeneradas, pues no es un método fiable 100%. Si se obtienen resultados muy raros o errores es recomendable ejecutar varias veces. Si eso no lo arregla, tocará calcular los focos a mano. <br>
Parámetros <br>
c: conica - cónica de la que calcular sus directrices <br>
</p>
</div>
</div>
</div>
<div class='function'>
<h3>Función: es_real(p)</h3>
<p>
Determina si un punto es real. <br>
Implementación <br>
Comrueba que coincida con su conjugado. <br>
Parámetros <br>
p: vector(n) - punto a comprobar <br>
</p>
</div>
</body>
</html>
