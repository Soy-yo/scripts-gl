<!doctype html>
<html>
<head>
<title>aplicaciones</title><link rel='stylesheet' type='text/css' href='style.css'></head>
<body>
<a href='index.html'>Página principal</a><h1>aplicaciones</h1>
<p>
Archivo que contiene clases relativas a aplicaciones proyectivas con operaciones simples y funciones creadoras de estas. <br>
Autor: Pablo Sanz Sanz <br>
</p>
<div class='class'>
<h2>Clase: aplicacion_proyectiva</h2>
<p>
Clase que representa una aplciación proyectiva de un subespacio arbitario en otro. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye una aplicacion poryectiva dadas su matriz asociada. <br>
En general, no está pensado para usarse directamente, sino para ser creada por otras funciones. <br>
Parámetros <br>
matriz: matriz(n, m) - matriz asociada a la aplicacion <br>
</p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta aplicación. </p>
</div>
<div class='function'>
<h3>Función: centro()</h3>
<p>
Devuelve el centro de esta aplicación proyectiva, que es el núcleo de la lineal asociada. <br>
Implementación <br>
Calcula el subespacio dual al que contiene las filas de la matriz asociada. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_inyectiva()</h3>
<p>
Determina si esta apliación es inyectiva. <br>
Implementación <br>
Comprueba que el rango de la matriz asociada coincida con el núemro de columnas. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_sobreyectiva()</h3>
<p>
Determina si esta apliación es sobreyectiva. <br>
Implementación <br>
Comprueba que el rango de la matriz asociada coincida con el núemro de filas. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_homografia()</h3>
<p>
Determina si esta apliación es una homografía (biyectiva). <br>
Implementación <br>
Comprueba que sea inyectiva y la matriz cuadrada. <br>
</p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta aplicación del punto dado. <br>
Uso: f(x) (donde f es una aplicacion_proyectiva, x un punto). <br>
Implementación <br>
Multiplica el vector por la matriz asociada. <br>
Parámetros <br>
x: vector(n) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: autovalores()</h3>
<p>
Calcula los autovalores de esta aplicación, asumiendo que va de un espacio en sí mismo. <br>
Implementación <br>
Resuelve det(f - lambda*id) = 0 para lambda (donde f es esta apliación). <br>
</p>
</div>
<div class='function'>
<h3>Función: autovectores()</h3>
<p>
Devuelve tuplas con los autovectores de la matriz asociada a esta aplicación. <br>
Para cada tupla, su primer elemento es el autovalor, el segundo la base del subespacio y el tercero la multiplicidad. <br>
<br>
Implementación <br>
Utilzia eigenvectors_right() de Sage. Para obtener los puntos fijos solamente usar puntos_fijos(). <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos()</h3>
<p>
Devuelve los puntos fijos de esta aplicacion proyectiva. <br>
Implementación <br>
Para cada autovalor lambda resuelve (f - lambda id)X = 0 para X (donde f es esta apliación). <br>
</p>
</div>
<div class='function'>
<h3>Función: cambiar_referencias(cambio_inicial = None, cambio_final = None, misma = True)</h3>
<p>
Devuelve una nueva apliación con los cambios de referencia especificados. <br>
Implementación <br>
REVISAR. Si las matrices son M, P y Q las de esta aplciación, el cambio de coordenadas incial y final, respectivamente, calcula Q*M*P^-1. Posiblemente esté al revés, esto es lo que hay que revisar. <br>
Parámetros <br>
cambio_inicial: matriz(m, m) - matriz del cambio de referencia del espacio de salida (por defecto I) <br>
cambio_final: matriz(n, n) - matriz del cambio de referencia del espacio de llegada (por defecto I o la misma que la anterior) <br>
misma: booleano - determina si se debe usar el mismo cambio de base en ambos espacios en caso de que no se especifique la matriz del espacio de llegada y sea posible <br>
</p>
</div>
<div class='function'>
<h3>Función: __mul__(otra)</h3>
<p>
Operador *. Devuelve la composición de las aplicaciones ((self o otra)(x) = self(otra(x))). <br>
Uso: f * g (f y g son aplicaciones compatibles para la composición). <br>
Implementación <br>
Devuelve una nueva aplicación cuya matriz sea el producto de las de ambas. <br>
Parámetros <br>
otra: aplicacion_proyectiva - aplciación con la que componer <br>
</p>
</div>
<div class='function'>
<h3>Función: __pow__(n)</h3>
<p>
Operador ^ (ó **). Devuelve el resultado de componer una aplicación consigo misma n veces (^-1 devuelve la inversa). <br>
Uso f^n (ó f**n) (f es una homografía de la recta y n un entero). <br>
Implementación <br>
Devuelve una nueva aplciación cuya matriz es la de esta elevada a n. <br>
Parámetros <br>
n: entero - exponente al que elevar <br>
</p>
</div>
</div>
</div>
</body>
</html>
