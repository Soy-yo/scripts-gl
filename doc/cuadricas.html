<!doctype html>
<html>
<head>
<title>cuadricas</title>
<meta charset='utf-8'><link rel='stylesheet' type='text/css' href='style.css'>
</head>
<body>
<a href='index.html'>Página principal</a><h1>cuadricas</h1>
<p>
Este archivo contiene clases para manejar cónicas y cuádricas y algunas otras funciones útiles. De momento no se ha implementado nada sobre cuádricas en general porque la mayoría de ejercicios son de cónicas, pero ciertos métodos serían exactamente iguales, sólo que en dimensión mayor. Se puede mirar el procedimiento y hacer a mano. <br>
Autor: Pablo Sanz Sanz <br>
</p>
<div class='function'>
<h3>Función: conica_degenerada(r1, r2 = None)</h3>
<p>
Devuelve la cónica degenerada que contiene las dos rectas dadas. Realmente, es más útil hacerlo a mano, así que no se dará implementación. Es útil para otras funciones. <br>
Parámetros <br>
r1: subespacio - primera recta de la cónica degenerada <br>
r2: subespacio - segunda recta de la cónica degenerada (r1 por defecto, es decir, recta doble) <br>
</p>
</div>
<div class='function'>
<h3>Función: conica_cinco_puntos(a, b, c, d, e)</h3>
<p>
Devuelve la cónica que pasa por los 5 puntos dados. <br>
NOTA. No puede haber cuatro de ellos alineados, pero la función no lo comprueba. <br>
Implementación <br>
Crea el haz de cónicas que pasa por las cónicas degeneradas AB * CD y AC * BD. Después se fuerza que pase por E. <br>
Parámetros <br>
a: vector(3) - primer punto de la cónica <br>
b: vector(3) - segundo punto de la cónica <br>
c: vector(3) - tercer punto de la cónica <br>
d: vector(3) - cuarto punto de la cónica <br>
e: vector(3) - quinto punto de la cónica <br>
</p>
</div>
<div class='function'>
<h3>Función: conica_por_homografia(h, e = 0)</h3>
<p>
Crea una cónica a partir de una homografía entre haces de rectas, dada como homografia_dos_rectas (cada una de las rectas representa el punto base de cada haz y se entiende que cada punto de cada recta es una recta del haz). La cónica es el resultado de intersecar r y h(r), donde r es una recta del primer haz y h(r) su imagen. Si la homografía es realmente entre dos rectas, el resultado obtenido será una parametrización de una cónica dual. <br>
NOTA. No se puede usar para perspectividades. El resultado simplemente sería el vértice como punto o como recta según la homografía fuera de una recta en otra o de un haz de rectas en otro, respectivamente. <br>
Implementación <br>
En una referencia adecuada una cónica puede parametrizarse como (1 : theta : theta^2). Esta referencia está dada por dos puntos de la cónica y el polo de la recta que los une. Se toman los puntos base de cada haz, que pertenecerán a la cónica, pues r intersecado con h(r), donde r es la recta que une los puntos base debe ser necesariamente el punto base del segundo haz, pues ambas pasan por él. Lo mismo sucede para h^-1(r) y r. Sólo falta obtener el polo de la recta r, que será el punto de intersección de las tangentes a la cónica desde los puntos base de cada haz. Estas tangentes tienen que ser, por tanto, h(r) y h^-1(r). Finalmente, se toma como referencia {P, Polo(PQ), Q; E}, con un punto unidad arbitrario de la cónica, calculado como la intersección de un punto cualquiera y su imagen, y se parametriza la cónica como (1 : theta : theta^2). <br>
Parámetros <br>
h: homografia_dos_rectas - homografía (entendida entre haces de rectas) que va a generar la cónica <br>
e: complejo/Infinity - coordenada del punto extra que se va a utilizar, que no debe coincidir con r ni h^-1(r) (por defecto 0, 1 o Infinity) <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble_conica(base, p0, p1, p2, p3)</h3>
<p>
Calcula la razón doble de 4 puntos sobre una cónica, dado un punto base también perteneciente a la misma. <br>
Como una cónica queda definida por 5 puntos no es necesario especificar explícitamente la cónica. <br>
Nótese que la razón doble debería ser la misma sea cual sea el punto base, siempre que se encuentre en la misma cónica y no sea uno de los otros. <br>
Ver también métodos similares en la clase parametrizacion_conica. <br>
Implementación <br>
Calcula la razón doble de las rectas que unen la base con cada uno de los puntos (ver razon_doble (recta_proyectiva.sage)). Los puntos deben ser todos distintos, aunque no se comprueba. <br>
Parámetros <br>
base: vector(3) - punto base del haz de rectas con el que se va a calcular la razón doble (debe pertenecer a la cónica) <br>
p0: vector(3) - primer punto de la razón doble (debe pertenecer a la cónica) <br>
p1: vector(3) - segundo punto de la razón doble (debe pertenecer a la cónica) <br>
p2: vector(3) - tercer punto de la razón doble (debe pertenecer a la cónica) <br>
p3: vector(3) - cuarto punto de la razón doble (debe pertenecer a la cónica) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_conica(a, ap, b, bp, c = None, cp = None, param = None, involucion = False)</h3>
<p>
Crea un objeto del tipo homografia_conica dados la parametrización de la cónica y tres puntos y sus imágenes. Es válido tanto para puntos como parámetros inhomogéneos. <br>
Si se quiere crear una involución dados dos puntos y sus imágenes se pueden omitir los terceros puntos. La función se podría llamar de la siguiente forma: h = crear_homografia_conica(a, ap, b, bp, param = p, involucion = True). <br>
Implementación <br>
Si se dan puntos se obtiene primero su coordenada de la cónica. Una vez obtenidas las coordenadas se crea una nueva homografía de una falsa recta en sí misma (ver crear_homografia_recta_theta() en recta_proyectiva.sage), que se utilizará para calcular la imagen de un parámetro no homogéneo. <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - primer punto a transformar <br>
ap: complejo/Infinity/vector(3) - imagen del primer punto <br>
b: complejo/Infinity/vector(3) - segundo punto a transformar <br>
bp: complejo/Infinity/vector(3) - imagen del segundo punto <br>
c: complejo/Infinity/vector(3) - tercer punto a transformar (no necesario si se va a crear una involución) <br>
cp: complejo/Infinity/vector(3) - imagen del tercer punto (no necesario si se va a crear una involución) <br>
param: parametrizacion_conica - cónica sobre la que actúa la homografía (por defecto (1, theta, theta^2)) <br>
involucion: booleano - True si se quiere crear una involución, False si no necesariamente (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_conica_eje(a, ap, param, eje, extra = 0)</h3>
<p>
Crea una homografía de una cónica dados un punto y su imagen y el eje de la homografía (como subespacio). Es válido tanto para puntos como parámetros inhomogéneos. <br>
Implementación <br>
Obtiene los puntos P, Q de corte del eje con la cónica. Estos serán puntos fijos. Así que se crea una homografía que lleve P a P, Q a Q y A a A' (el punto dado). En caso de obtenerse un único punto fijo (el eje era tangente) se calcula la imagen del punto extra B dado hallanda el corte X entre BA' con el eje y de nuevo el corte de la recta AX con la cónica, que será su imagen. Entonces ya tenemos una homografía que transforma P en P, A en A' y B en B'. <br>
NOTA. Por simplicidad no se hacen comprobaciones sobre puntos coincidentes, pero se debe asegurar que ninguno de los puntos que se da como parámetros (tanto a, ap, como extra) coincida con la intersección (o entre ellos). En caso contrario es probable encontrarse con resultados extraños o incluso errores. <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - punto a transformar <br>
ap: complejo/Infinity/vector(3) - imagen del punto <br>
param: parametrizacion_conica - cónica sobre la que actúa la homografía <br>
eje: subespacio - eje de la homografía (nótese que se pide un subespacio) <br>
extra: complejo/Infinity/vector(3) - punto extra de la cónica que se utilizará en caso de que el corte del eje con la cónica sea un único punto (0) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_conica_fijos(a, ap, param, m, n = None, extra = 0)</h3>
<p>
Crea una homografía de una cónica dados un punto y su imagen y los puntos fijos. Es válido tanto para puntos como parámetros inhomogéneos. <br>
Implementación <br>
Utiliza la función crear_homografia_conica_eje calculando primero el eje, que será la recta que une los puntos fijos o la tangente en el caso de un único punto fijo. Si se tienen dos puntos fijos se puede usar directamente la función principal, sin necesidad de calcular el eje. <br>
NOTA. Por simplicidad no se hacen comprobaciones sobre puntos coincidentes, pero se debe asegurar que ninguno de los puntos que se da como parámetros (tanto a, ap, como extra) coincida con la intersección (o entre ellos). En caso contrario es probable encontrarse con resultados extraños o incluso errores. <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - punto a transformar <br>
ap: complejo/Infinity/vector(3) - imagen del punto <br>
param: parametrizacion_conica - cónica sobre la que actúa la homografía <br>
m: complejo/Infinity/vector(3) - primer punto fijo <br>
n: complejo/Infinity/vector(3) - segundo punto fijo (por defecto ninguno) <br>
extra: complejo/Infinity/vector(3) - punto extra de la cónica que se utilizará si sólo hay un punto fijo (por defecto 0) <br>
</p>
</div>
<div class='class'>
<h2>Clase: conica</h2>
<p>
Clase que representa una cónica tanto puntual como dual dada su matriz. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor (matriz)</h3>
<p>
Construye una cónica dada su matriz. Si se quiere crear mediante una ecuación es recomendable hacerlo a mano (matriz simétrica con coeficientes de variables al cuadrado en la diagonal y en el resto de posiciones la mitad del coeficiente según las variables). Se puede usar también ecuacion.hessian() pero puede dar problemas si se tiene algún parámetro o si no aparecen las tres variables. <br>
Parámetros <br>
matriz: matriz(3, 3) - matriz de la cónica <br>
</p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta cónica. </p>
</div>
<div class='function'>
<h3>Función: ecuacion(factor = False)</h3>
<p>
Devuelve la ecuación de esta cónica. <br>
Parámetros <br>
factor: booleano - indica si se quiere la ecuación factorizada (en caso de degeneradas quizá pueda separarla en dos rectas) o no (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: es_degenerada()</h3>
<p>
Determina si esta cónica es degenerada, esto es, si el rango de su matriz asociada no es 3. </p>
</div>
<div class='function'>
<h3>Función: es_dos_rectas()</h3>
<p>
Determina si esta cónica es el producto de dos rectas, esto es, si el rango de su matriz asociada es 2. </p>
</div>
<div class='function'>
<h3>Función: es_recta_doble()</h3>
<p>
Determina si esta cónica es una recta doble, esto es, si el rango de su matriz asociada es 1. </p>
</div>
<div class='function'>
<h3>Función: puntos(x0 = None, y0 = None, z0 = None)</h3>
<p>
Devuelve una tupla conteniendo los dos puntos de la cónica dadas dos de sus coordenadas. No se deben dar ni más ni menos. Devolverá dos veces el mismo punto si sólo hay un punto que cumpla esas condiciones. Devolverá una tupla con dos vectores vacíos en caso de no encontrar ninguno. <br>
Uso: (P, Q) = c.puntos(x0 = x, y0 = y) (donde c es una cónica, x, y son números); similarmente: P = c.puntos(x0 = x, z0 = z), P = c.puntos(y0 = y, z0 = z) <br>
Implementación <br>
Resuelve la ecuación de la cónica sustituyendo los valores dados para la variable no dada. <br>
Parámetros <br>
x0: complejo - coordenada x del punto que se quiere obtener (si no se especifica será la que se calcule) <br>
y0: complejo - coordenada y del punto que se quiere obtener (si no se especifica será la que se calcule) <br>
z0: complejo - coordenada z del punto que se quiere obtener (si no se especifica será la que se calcule) <br>
</p>
</div>
<div class='function'>
<h3>Función: es_tangente(r)</h3>
<p>
Determina si la recta dada es tangente a esta cónica. <br>
Implementación <br>
Comprueba que el punto dual de la recta pertenezca a la cónica dual. <br>
Parámetros <br>
r: subespacio - recta a comprobar si es tangente o no <br>
</p>
</div>
<div class='function'>
<h3>Función: cambiar_referencia(matriz_cambio)</h3>
<p>
Devuelve una nueva cónica expresada en la nueva referencia R', dada la matriz del cambio de referencia de R a R'. <br>
La matriz del cambio de referencia debería proceder de cambiar_referencia (espacios.sage). <br>
Implementación <br>
Si A es la matriz asociada a esta cónica y M la matriz del cambio de referencia entre dos referencias (que esta cónica desconoce), se crea una nueva cónica cuya matriz asociada sea M^-t * A * M^-1. <br>
Parámetros <br>
matriz_cambio: matriz(3, 3) - matriz que representa el cambio de referencia: x' = Ax <br>
</p>
</div>
<div class='function'>
<h3>Función: dual()</h3>
<p>
Devuelve la cónica dual (de rectas tangentes) a esta cónica. <br>
Implementación <br>
Se crea una nueva cónica cuya matriz asociada sea la adjunta de la de esta. <br>
</p>
</div>
<div class='function'>
<h3>Función: polar(p)</h3>
<p>
Devuelve la recta polar del punto P respecto de esta cónica. <br>
Implementación <br>
Si A es la matriz asociada a esta cónica, la recta polar es la de ecuación x^t * A * p = 0. <br>
Parámetros <br>
p: vector(3) - punto del que se quiere calcular su polar <br>
</p>
</div>
<div class='function'>
<h3>Función: polo(r)</h3>
<p>
Devuelve el polo de la recta r respecto de esta cónica. <br>
Implementación <br>
Se calcula la recta polar del punto dual de la recta r* (el vector de sus coeficientes) respecto a la cónica dual C*. Por tanto, el dual de la recta polar calculada será el punto buscado. <br>
Parámetros <br>
r: subespacio - recta de la que calcular el polo <br>
</p>
</div>
<div class='function'>
<h3>Función: tangentes(p)</h3>
<p>
Devuelve la cónica degenerada tangente a esta cónica que pasa por P. <br>
Implementación <br>
Devuelve la cónica de matriz A * p * p^t * A - (p^t * A * p) * A, donde A es la matriz asociada a esta cónica. <br>
Parámetros <br>
p: vector(3) - punto del que obtener las tangentes <br>
</p>
</div>
<div class='function'>
<h3>Función: interseccion()</h3>
<p>
Devuelve la intersección de las rectas de esta cónica degenerada. Devuelve un subespacio, si sólo se quiere un punto, en caso de ser dos rectas distintas, se puede usar .representantes()[0] para obtenerlo como vector. Si la cónica no es degenerada devuelve un subespacio vacío. <br>
Implementación <br>
Calcula el núcleo de la matriz asociada, que será la intersección de las rectas. <br>
</p>
</div>
<div class='function'>
<h3>Función: interseccion_recta(r)</h3>
<p>
Devuelve una tupla conteniendo los dos puntos de intersección de una recta (expresada como recta_proyectiva) con esta cónica. Si la recta fuera tangente (esto es, corta en un punto doble) devolverá dos veces el mismo punto. <br>
Implementación <br>
Tomado un punto genérico de la recta, P(theta), resuelve P^t(theta) * A * P(theta) = 0, siendo A la matriz que representa esta cónica. <br>
Parámetros <br>
r: recta_proyectiva(dim=2) - recta con la que intersecar <br>
</p>
</div>
<div class='function'>
<h3>Función: interseccion_conica(param)</h3>
<p>
Devuelve una tupla con los cuatro puntos de intersección de esta cónica con otra cónica, dada su parametrización. <br>
NOTA. No será posible intersecar cónicas ambas degeneradas, pues ninguna se podría parametrizar. En tal caso, es recomendable buscar las rectas que forman alguna de ellas e intersecar con las rectas. <br>
Implementación <br>
Resuelve la ecuación c^t(theta) * A * c(theta), donde c es la parametrización de la otra cónica y A es la matriz de esta. <br>
Parámetros <br>
param: parametrizacion_conica - parametrización de la cónica con la que intersecar <br>
</p>
</div>
<div class='function'>
<h3>Función: triangulo_autopolar(p, q)</h3>
<p>
Devuelve el tercer punto que forma un triángulo autopolar junto con los otros dos dados, asumiendo que cada uno está en la polar del otro. <br>
Si se tiene sólo un punto se debe calcular antes su polar y de ahí elegir un punto arbitrario para que sea el segundo. <br>
Implementación <br>
Interseca las rectas polares de los puntos dados. <br>
Parámetros <br>
p: vector(3) - un punto del triángulo <br>
q: vector(3) - otro punto del triángulo <br>
</p>
</div>
<div class='function'>
<h3>Función: es_triangulo_autopolar(p, q, r)</h3>
<p>
Determina si P, Q, R forman un triángulo autopolar. <br>
Implementación <br>
Comprueba que Q y R pertenezcan a la polar de P. <br>
Parámetros <br>
p: vector(3) - primer punto del triángulo autopolar <br>
q: vector(3) - segundo punto del triángulo autopolar <br>
r: vector(3) - tercer punto del triángulo autopolar <br>
</p>
</div>
<div class='function'>
<h3>Función: referencia_autopolar(p, q, r, real = False)</h3>
<p>
Devuelve el punto unidad E para la referencia {P, Q, R; E} que hace que esta cónica tenga ecuación x^2 + y^2 + z^2 = 0 en complejos, quizá algunos negativos en reales. Nótese que no cambia la cónica, sino que se debe obtener primero la matriz del cambio de referencia (ver cambiar_referencia() en espacios.sage) y luego cambiar la referencia de esta cónica. <br>
NOTA. Los puntos P, Q, R deben formar un triángulo autopolar. <br>
Implementación <br>
Con un punto E arbitrario la ecuación de esta cónica es ax^2 + by^2 + cz^2 = 0, donde a, b y c se calculan mediante B(P, P), B(Q, Q), B(R, R), respectivamente (donde B es la forma bilineal asociada a esta cónica). Entonces sólo necesitamos eliminar estos a, b y c. Esto se hace eligiendo los representantes de P, Q y R de forma que E = [beta1 * P + beta2 * Q + beta3 * R], donde a*beta1^2 = 1, b*beta2^2 = 1 y c*beta3^2 = 1 (si a, b o c son 0 se elige betai = 1). <br>
Para el caso real se igualan a -1 si no se puede resolver la ecuación. <br>
Parámetros <br>
p: vector(3) - primer punto del triángulo autopolar <br>
q: vector(3) - segundo punto del triángulo autopolar <br>
r: vector(3) - tercer punto del triángulo autopolar <br>
real: booleano - determina si la cónica debe ser necesariamente real o no (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: parametrizar(p, r, e)</h3>
<p>
Devuelve una parametrización de la cónica, dados tres puntos contenidos en ella que actuarán como primero, tercero y unidad de la referencia en la que la cónica tiene ecuación y^2=xz. <br>
Implementación <br>
Calcula las polares (tangentes por estar en la cónica) de los dos primeros puntos: P, R, para obtener el tercero, que será el corte de ambas rectas: Q. Tomando como referencia entonces {P, Q, R; E}, la ecuación de la cónica sería y^2=xz. Por tanto, se puede parametrizar como (1, theta, theta^2). <br>
Parámetros <br>
p: vector(3) - primer punto de la referencia (debe pertenecer a la cóncia) <br>
r: vector(3) - tercer punto de la referencia (debe pertenecer a la cóncia) <br>
e: vector(3) - punto unidad de la referencia (debe pertenecer a la cóncia) <br>
</p>
</div>
<div class='function'>
<h3>Función: factorizacion()</h3>
<p>
--- NO RECOMENDABLE USAR --- <br>
Factoriza esta cónica degenerada en dos rectas. Devuelve una tupla conteniendo las dos rectas como subespacios, que serán la misma en caso de que la cónica sea una recta doble. <br>
IMPORTANTE. No es un método muy fiable, pues depende de cierta aleatoriedad, con lo que las rectas obtenidas pueden no estar simplificadas. Es más recomendable pedir la ecuación factorizada (c.ecuacion(True)) y crear las rectas a mano a partir de los coeficientes de la ecuación. <br>
Implementación <br>
Si es una recta doble (rango 1) se interseca con dos rectas cualesquiera y se unen los puntos. Si son dos rectas (rango 2) se toma el punto de intersección y la intersección con otra recta que no pase por ese punto. <br>
</p>
</div>
<div class='function'>
<h3>Función: __call__(p)</h3>
<p>
Calcula la imagen de un punto mediante la forma bilineal que define esta cónica. Realmente esta no es una operación de cónicas, pero se incluye aquí porque puede ser útil. <br>
Uso: c(p) (donde c es una cónica y p un punto). <br>
Implementación <br>
Calcula p^t * A * p, donde A es la matriz asociada a esta cónica. <br>
Parámetros <br>
p: vector(3) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: __contains__(punto)</h3>
<p>
Operador in. Determina si un punto está contenido en esta cónica o no. <br>
Uso: P in c (P es un punto y c una cónica). <br>
Implementación <br>
Comprueba p^t * A * p = 0 para A la matriz asociada de la cónica. <br>
Parámetros <br>
punto: vector(3) - punto que comprobar si pertenece a la cónica <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: parametrizacion_conica</h2>
<p>
Clase que representa una parametrización de una cónica no degenerada de la forma (p1(theta), p2(theta), p3(theta)), siendo pi polinomios de grado 2. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor (matriz, matriz_cambio = identity_matrix(3))</h3>
<p>
Construye una parametrización de una cónica dadas la matriz M que determina las coordenadas de cada punto, que se obtienen como M * (1, theta, theta^2). M será la matriz que hace que la cónica se exprese como y^2=xz. <br>
También se puede indicar una matriz de cambio de referencia extra para casos del tipo (por ejemplo) parametrizar una cónica como (1, theta, theta^2). <br>
Parámetros <br>
matriz: matriz(3, 3) - matriz que representa los puntos genéricos de la parametrización como se explica arriba <br>
matriz_cambio: matriz(3, 3) - matriz del cambio de referencia para convertir la referencia en que se encuentra la parametrización a la canónica (identidad por defecto, esto es, ya se expresa en la canónica) <br>
</p>
</div>
<div class='function'>
<h3>Función: punto_generico()</h3>
<p>
Devuelve un punto genérico de la parametrización expresado en la referencia en que se encuentra la parametrización. <br>
Diferenciar del operador [] en que c[theta_0] SÍ que cambia la referencia a la referencia original. Este método NO. <br>
</p>
</div>
<div class='function'>
<h3>Función: __getitem__(theta)</h3>
<p>
Devuelve el punto con coordenada theta. <br>
Uso: c[theta_0] (theta_0 es la coordenada del punto y c es parametrizacion_conica). <br>
Si se quiere un punto genérico de la cónica, sustituir por una variable (ej: c[x] devuelve un punto dependiente de x). <br>
Parámetros <br>
theta: complejo/Infinity - coordenada del punto de la cónica que se quiere obtener <br>
</p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia en que está expresada esta parametrización en función de la referencia canónica (es decir, las columnas de la matriz del cambio y la suma de ellas). </p>
</div>
<div class='function'>
<h3>Función: referencia2()</h3>
<p>
Devuelve la referencia en que esta cónica tiene coordenadas (1, theta, theta^2) (las columnas de la matriz que representa los puntos genéricos de la parametrización). <br>
NOTA. No estoy muy seguro pero creo que esto está dado en función de la primera referencia. </p>
</div>
<div class='function'>
<h3>Función: conica()</h3>
<p>
Devuelve la cónica que representa esta parametrización. <br>
Implementación <br>
Conociendo la matriz que representa la parametrización y la del cambio de referencia (ambas son cambios de referencia al fin y al cabo), la cónica tendrá ecuación y^2=xz, por tanto, hay que cambiar de referencia esa cónica primero por la matriz que representa la parametrización, P, y luego por la del cambio de referencia, M: M^-t * P^-t * A * P^-1 * M^-1 <br>
</p>
</div>
<div class='function'>
<h3>Función: coordenada(p)</h3>
<p>
Devuelve la coordenada no homogénea asociada al punto P dado. <br>
Implementación <br>
Resuelve la ecuación (p1(theta) : p2(theta) : p3(theta)) == P. Se asume que el punto está en la cónica. <br>
Parámetros <br>
p: vector(3) - punto de la cónica del que se quiere conocer su coordenada <br>
</p>
</div>
<div class='function'>
<h3>Función: interseccion_recta(r, original = True)</h3>
<p>
Devuelve una tupla conteniendo los dos puntos de intersección de una recta (expresada como subespacio) con esta cónica. Si la recta fuera tangente (esto es, corta en un punto doble) devolverá dos veces el mismo punto. <br>
La recta puede venir dada tanto para coordenadas en la referencia de la recta como para coordenadas en la referencia original. Esto sólo cambiará el orden del producto. <br>
Implementación <br>
Tomado un punto genérico de la cónica, P(theta), lo sustituye en la ecuación implícita de la recta y la resuelve. <br>
Parámetros <br>
r: subespacio(dim=1, dim_ambiente=2) - recta con la que intersecar <br>
original: booleano - determina si se usa la referencia original o no (True por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: __contains__(punto)</h3>
<p>
Operador in. Determina si un punto está contenido en esta cónica o no. El punto dado debe estar en la referencia inicial. Es decir, si la parametrización es (1 : theta : theta^2), por ejemplo, el punto (1:1:1) no tiene por qué estar contenido en la cónica si la referencia es otra. <br>
Uso: P in c (P es un punto y c una parametrización de una cónica). <br>
Implementación <br>
Comprueba si la ecuación (p1(theta) : p2(theta) : p3(theta)) == P tiene solución. <br>
Parámetros <br>
punto: vector(3) - punto que comprobar si pertenece a la cónica <br>
</p>
</div>
</div>
</div>
<div class='function'>
<h3>Función: razon_doble(a, b, c, d)</h3>
<p>
Calcula la razón doble {A, B; C, D}. Es válido tanto para puntos como para parámetros inhomogéneos de la cónica. <br>
Implementación <br>
Una vez obtenida la coordenada de cada punto se utiliza razon_doble_theta (ver recta_proyectiva.sage). <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(3) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(3) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(3) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica(a, b, c, d)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {A, B; C, D} = -1. Es válido tanto para puntos como para parámetros inhomogéneos de una cónica. <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(3) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(3) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(3) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico(a, b, c)</h3>
<p>
Devuelve el conjugado armónico de c respecto de a y b. Es válido tanto para puntos como para parámetros inhomogéneos de una cónica. <br>
Parámetros <br>
a: complejo/Infinity/vector(3) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(3) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(3) - tercer punto de la razón doble <br>
</p>
</div>
<div class='class'>
<h2>Clase: homografia_conica</h2>
<p>
Clase que representa una homografía de una cónica en sí misma. <br>
Se representa mediante una falsa homografía de una recta en sí misma, que para lo único que servirá será para aprovechar sus métodos. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor (homografia, param)</h3>
<p>
Construye una homografía de una cónica dada una homografía de una falsa recta en sí misma y la parametrización de la cónica. <br>
En general, no se usará este constructor directamente, sino que se creará a partir de funciones creadoras externas. <br>
Parámetros <br>
homografia: homografia_recta - homografía que convierte la coordenada inhomogénea de un punto de la cónica en su imagen <br>
param: parametrizacion_conica - conica sobre la que actúa la homografía <br>
</p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta homografía. </p>
</div>
<div class='function'>
<h3>Función: parametrizacion_conica()</h3>
<p>
Devuelve la parametrización de la cónica de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia en la que está expresada la cónica. </p>
</div>
<div class='function'>
<h3>Función: expresion_mobius()</h3>
<p>
Devuelve la homografía expresada como una transformación de Möbius. </p>
</div>
<div class='function'>
<h3>Función: ecuacion()</h3>
<p>
Devuelve la ecuación en theta y theta' de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta homografía del punto dado. <br>
Uso: h(x) ó h(p) (donde r es una homografia_conica, x un complejo/Infinity y p un punto). <br>
Implementación <br>
Calcula el parámetro no homogéneo asociado a la imagen del punto dado mediante la falsa homografía. <br>
Si se ha dado un parámetro devolverá el parámetro y si se ha dado un punto devolverá el punto. <br>
Parámetros <br>
x: complejo/Infinity/vector(n) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos_theta()</h3>
<p>
Devuelve los parámetros de los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Ver homografia_recta.puntos_fijos_theta() (recta_proyectiva.sage). <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos()</h3>
<p>
Devuelve los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Ver homografia_recta.puntos_fijos() (recta_proyectiva.sage). <br>
</p>
</div>
<div class='function'>
<h3>Función: eje()</h3>
<p>
Calcula el eje de esta homografía. <br>
Implementación <br>
Se unen los puntos fijos en caso de haber dos o se obtiene la recta tangente al punto fijo en caso de haber uno. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_involucion()</h3>
<p>
Determina si esta homografía es una involución. <br>
Implementación <br>
Comprueba que la homografía al cuadrado sea la identidad. <br>
</p>
</div>
<div class='function'>
<h3>Función: modulo()</h3>
<p>
Calcula el módulo de esta homografía. Ver homografia_recta.modulo() (recta_proyectiva.sage). <br>
</p>
</div>
<div class='function'>
<h3>Función: centro()</h3>
<p>
Calcula el punto centro de esta involución. <br>
Implementación <br>
Calcula el corte de las rectas tangentes de los puntos fijos. Se asume que esta homografía es una involución. <br>
</p>
</div>
<div class='function'>
<h3>Función: descomponer(centro, tipo_conica = False)</h3>
<p>
Descompone esta homografía en dos involuciones dado el centro de la primera (s1), de forma que h = s2*s1, donde h es esta homografía. Téngase en cuenta la forma de calcular las imágenes: primero se aplica s1 y luego s2 (s2(s1(x))). <br>
El centro dado debe encontrarse en el eje de la homografía, porque si no se complica demasiado. <br>
El resultado se da como una tupla que contiene dos objetos del tipo involucion_conica. <br>
Implementación <br>
Crea una primera involución con el centro dado. Se obtienen sus puntos fijos. Uno de ellos al menos no es fijo en la homografía. Este punto fijo de la involución se une con una recta con su imagen original y se interseca con el eje de la homografía. Este será el centro de la segunda homografía (si tenía un solo punto fijo ambas involuciones lo mantienen y si tenía dos ambas involuciones los intercambian). <br>
Parámetros <br>
centro: vector(3) - punto que actuará como centro de la primera involución (debe pertenecer al eje de la homografía) <br>
tipo_conica: booleano - determina si la involución se creará con la parametrización de la cónica o la cónica como tal (False por defecto; no se mostrará procedimiento de la transformación igualmente) <br>
</p>
</div>
<div class='function'>
<h3>Función: __mul__(otra)</h3>
<p>
Operador *. Devuelve la composición de las homografías ((self o otra)(theta) = self(otra(theta))). Ambas deben ser de la misma cónica, con la misma parametrización. <br>
Uso: h * k (h y k son homografías de la misma cónica). <br>
Implementación <br>
Crea una nueva homografía de la cónica cuya homografía de la recta asociada sea el producto de la homografía asociada a esta cónica por la de la otra. Ver operador * (__mul__) de homografia_recta (recta_proyectiva.sage). <br>
NOTA. Por simplicidad NO se comprueba que las parametrizaciones sean iguales. En caso contrario, el resultado no será válido (nótese que se usa la cónica de esta homografía para crear la nueva). <br>
Parámetros <br>
otra: homografia_conica - homografía con la que componer <br>
</p>
</div>
<div class='function'>
<h3>Función: __pow__(n)</h3>
<p>
Operador ^ (ó **). Devuelve el resultado de componer una homografía con sí misma n veces (^-1 devuelve la inversa). <br>
Uso h^n (ó h**n) (h es una homografía de una cónica y n un entero). <br>
Implementación <br>
Crea una nueva homografía de la cónica cuya homografía de la recta asociada sea la homografía asociada a esta cónica elevada a n. Ver operador ^/** (__pow__) de homografia_recta (recta_proyectiva.sage). <br>
Parámetros <br>
n: entero - exponente al que elevar <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: involucion_conica</h2>
<p>
Clase que define una involución sobre una cónica, conocido alguno de sus elementos. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor (conica, vertice = None, fijos = None, eje = None)</h3>
<p>
Construye una involución sabiendo la cónica al menos unos de sus elementos: vértice, puntos fijos o eje. <br>
Nótese que si se da una cónica y el eje, este debe ser del tipo recta_proyectiva y si se da una parametrización de la cónica el eje debe ser un subespacio. <br>
En caso de dar más información de la necesaria, sólo se hará caso al parámetro que aparezca antes. <br>
Por ejemplo involucion_conica(c, v, e) ignorará el eje y sólo se quedará con el vértice; o involucion_conica(c, eje = e, fijos = (m, n)) ignorará los puntos fijos. <br>
Implementación <br>
Si no se da el vértice se calcula como el polo del eje: la recta que une los puntos fijos. <br>
Parámetros <br>
conica: conica/parametrizacion_conica - cónica sobre la que actúa la involución <br>
vertice: vector(3) - vértice de la involución (por defecto el cálculo que se explica más arriba) <br>
eje: recta_proyectiva(dim=2)/subespacio(dim=1,dim_ambiente=2) - eje de la involución (por defecto no se determina) <br>
fijos: tupla(vector(3), vector(3)) - puntos fijos de la involución, ambos puntos de la cónica (por defecto no se determinan) <br>
</p>
</div>
<div class='function'>
<h3>Función: conica()</h3>
<p>
Devuelve la cónica sobre la que se aplica esta involución. Puede ser de tipo conica o parametrizacion_conica. </p>
</div>
<div class='function'>
<h3>Función: vertice()</h3>
<p>
Devuelve el vértice de esta involución. </p>
</div>
<div class='function'>
<h3>Función: eje()</h3>
<p>
Devuelve el eje de esta involución. <br>
Implementación <br>
Si se conocía en el momento de la creación simplemente lo devuelve. <br>
Si no, calcula la polar del vértice. <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos()</h3>
<p>
Devuelve los dos puntos fijos de esta involución. <br>
Implementación <br>
Si se conocían en el momento de la creación simplemente los devuelve. <br>
Si no, calcula la intersección del eje con la cónica. <br>
</p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta involución del punto dado. Si se tiene una parametrización de la cónica se puede dar la coordenada no homogénea del punto. <br>
Uso: h(x) (donde h es una involución y x un punto de la cónica). <br>
Implementación <br>
Calcula V(V, x) como subespacio o recta_proyectiva dependiendo de cómo sea haya dado la cónica y lo interseca con esta. Se devuelve el otro punto de intersección. <br>
Parámetros <br>
x: complejo/Infinity/vector(3) - punto de la cónica que se quiere calcular su imagen <br>
</p>
</div>
</div>
</div>
</body>
</html>
