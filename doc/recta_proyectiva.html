<!doctype html>
<html>
<head>
<title>recta_proyectiva</title><link rel='stylesheet' type='text/css' href='style.css'></head>
<body>
<a href='index.html'>Página principal</a><h1>recta_proyectiva</h1>
<p>
Este archivo proporciona diferentes funciones y clases sobre razones dobles y homografías de la recta. <br>
Suponemos que los puntos expresados con coordenada inhomogénea theta se obtiene mediante x/y. <br>
Autor: Pablo Sanz Sanz <br>
</p>
<div class='function'>
<h3>Función: es_parametro(x)</h3>
<p>
Función auxiliar que determina si el parámetro recibido es un punto (tipo vector) o un parámetro inhomogéneo de una recta proyectiva. <br>
Parámetros <br>
x: complejo/Infinity/variable/vector(n>1) - elemento a considerar <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble(a, b, c, d)</h3>
<p>
Calcula la razón doble {A, B; C, D}. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver razon_doble_puntos y razon_doble_theta, respectivamente). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble_puntos(p0, p1, p2, p3)</h3>
<p>
Calcula la razón doble ({P0, P1, P2, P3}) de los puntos alineados dados. <br>
Implementación <br>
Utiliza que la razón doble es invariante por proyecciones y la fórmula de la razón doble de los determinantes. Se elige una proyección que siga siendo una recta. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
p3: vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble_theta(theta0, theta1, theta2, theta3)</h3>
<p>
Calcula la razón doble ({theta0, theta1, theta2, theta3}) de los puntos de la recta dados (con parámetro no homogéneo). <br>
Implementación <br>
Utiliza la razón doble definida para puntos tras homogeneizar las coordenadas. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
theta3: complejo/Infinity - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica(a, b, c, d)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {A, B; C, D} = -1. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver es_cuaterna_armonica_puntos y es_cuaterna_armonica_theta, respectivamente). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica_puntos(p0, p1, p2, p3)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {P0, P1, P2, P3} = -1. <br>
Implementación <br>
Devuelve {P0, P1; P2, P3} == -1 utilizando las funciones anteriores. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
p3: vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica_theta(theta0, theta1, theta2, theta3)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {theta0, theta1, theta2, theta3} = -1. <br>
Implementación <br>
Devuelve {theta0, theta1; theta2, theta3} == -1 utilizando las funciones anteriores. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
theta3: complejo/Infinity - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico(a, b, c)</h3>
<p>
Devuelve el conjugado armónico de c respecto de a y b. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver conjugado_armonico_puntos y conjugado_armonico_theta, respectivamente). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
<br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico_puntos(p0, p1, p2)</h3>
<p>
Devuelve el conjugado armónico de p2 respecto de p0 y p1. <br>
Implementación <br>
Como la razón doble es la coordenada del cuarto punto respecto a la referencia {p0, p1; p2}, obtiene la recta que forman p0, p1 y p2 y devuelve el punto correspondiente a la coordenada theta == -1. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico_theta(theta0, theta1, theta2)</h3>
<p>
Devuelve el conjugado armónico de theta2 respecto de theta0 y theta1. <br>
Implementación <br>
Resuelve la ecuación {theta0, theta1, theta2, theta} == -1 en theta utilizando las funciones anteriores. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_recta(a, ap, b, bp, c = None, cp = None, recta = None, involucion = False)</h3>
<p>
Crea un objeto del tipo homografia_recta dados la recta y tres puntos y sus imágenes. Es válido tanto para puntos como parámetros inhomogéneos. <br>
Si se quiere crear una involución dados dos puntos y sus imágenes se pueden omitir los terceros puntos. La función se podría llamar de la siguiente forma: h = crear_homografia_recta(a, ap, b, bp, recta = r, involucion = True), si se especifica una recta r. <br>
Diferenciar de crear_aplicacion_proyectiva (aplicaciones.sage) en el orden de los argumentos y en que aquí no se piden listas. <br>
Implementación <br>
Si se dan puntos se obtiene primero su coordenada de la recta. Una vez obtenidas las coordenadas se usa crear_homografia_recta_theta. <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto a transformar <br>
ap: complejo/Infinity/vector(n>1) - imagen del primer punto <br>
b: complejo/Infinity/vector(n>1) - segundo punto a transformar <br>
bp: complejo/Infinity/vector(n>1) - imagen del segundo punto <br>
c: complejo/Infinity/vector(n>1) - tercer punto a transformar (no necesario si se va a crear una involución) <br>
cp: complejo/Infinity/vector(n>1) - imagen del tercer punto (no necesario si se va a crear una involución) <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto la recta que ponga homografia_recta por defecto (sólo válido para parámetros inhomogéneos)) <br>
involucion: booleano - True si se quiere crear una involución, False si no necesariamente (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_recta_theta(theta0, theta0p, theta1, theta1p, theta2 = None, theta2p = None, recta = None, involucion = False)</h3>
<p>
Crea un objeto del tipo homografia_recta dados la recta y tres puntos (con parámetros inhomogéneos) y sus imágenes. <br>
Si se quiere crear una involución dados dos puntos y sus imágenes se pueden omitir los terceros puntos. La función se podría llamar de la siguiente forma: h = crear_homografia_recta_theta(theta0, theta0p, theta1, theta1p, recta = r, involucion = True), si se especifica una recta r. <br>
Diferenciar de crear_aplicacion_proyectiva (aplicaciones.sage) en el orden de los argumentos y en que aquí no se piden listas. <br>
Implementación <br>
Se crea una primera homografía con ecuación theta' = (a*theta + b) / (c*theta + d), se sustituyen cada uno de los puntos dados y se resuelve el sistema. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto a transformar <br>
theta0p: complejo/Infinity - imagen del primer punto <br>
theta1: complejo/Infinity - segundo punto a transformar <br>
theta1p: complejo/Infinity - imagen del segundo punto <br>
theta2: complejo/Infinity - tercer punto a transformar (no necesario si se va a crear una involución) <br>
theta2p: complejo/Infinity - imagen del tercer punto (no necesario si se va a crear una involución) <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto la recta que ponga homografia_recta por defecto (sólo válido para parámetros inhomogéneos)) <br>
involucion: booleano - True si se quiere crear una involución, False si no necesariamente (False por defecto) <br>
</p>
</div>
<div class='class'>
<h2>Clase: recta_proyectiva</h2>
<p>
Clase que representa una recta proyectiva para cualquier dimension ambiente. Sirve para cálculos de razones dobles o para homografías entre rectas. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Inicializa la recta dada la referencia {p0, p1; p2} que se quiere utilizar. <br>
Implementación <br>
Obtiene la matriz asociada a la referencia dada (esto es, multiplicando el vector asociado a p0 y p1 por un coeficiente de forma que a*p0 + b*p1 == p2) y construye el punto b*p1 + theta*a*p0. <br>
Parámetros <br>
p0: vector(n) - punto cuya coordenada será theta == Infinity <br>
p1: vector(n) - punto cuya coordenada será theta == 0 <br>
p2: vector(n) - punto cuya coordenada será theta == 1 <br>
</p>
</div>
<div class='function'>
<h3>Función: __getitem__(theta)</h3>
<p>
Devuelve el punto con coordenada theta. <br>
Uso: r[theta_0] (theta_0 es la coordenada del punto y r es una recta(_proyectiva)). <br>
Parámetros <br>
theta: complejo/Infinity - coordenada del punto de la recta que se quiere obtener <br>
</p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia de esta recta proyectiva en forma de lista [Infinity, 0, 1]. </p>
</div>
<div class='function'>
<h3>Función: subespacio()</h3>
<p>
Devuelve esta recta proyectiva como objeto del tipo subespacio. </p>
</div>
<div class='function'>
<h3>Función: coordenada(p)</h3>
<p>
Devuelve la coordenada no homogénea asociada al punto p dado. <br>
Implementación <br>
Resuelve la ecuación recta(theta) == alpha * p para theta. <br>
Parámetros <br>
p: vector(n) - punto de la recta del que se quiere conocer su coordenada <br>
</p>
</div>
<div class='function'>
<h3>Función: __eq__(otra)</h3>
<p>
Operador ==. Determina si dos rectas proyectivas son iguales. <br>
Uso: r == s (r y s son rectas proyectivas). <br>
Implementación <br>
Comrpueba que el subespacio sea el mismo. <br>
Parámetros <br>
otra: recta_proyectiva - recta a comprobar la igualdad <br>
</p>
</div>
<div class='function'>
<h3>Función: __contains__(punto)</h3>
<p>
Operador in. Determina si un punto está contenido en este subespacio o no. <br>
Uso: P in r (P es un punto y r una recta proyectiva). <br>
Implementación <br>
Comprueba que el punto pertenezca al subespacio asociado. <br>
Parámetros <br>
punto: vector(n) - punto que comprobar si pertenece a la recta <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: homografia_recta</h2>
<p>
Clase que representa una homografía de una recta en sí misma. En general, se crearán usando funciones auxiliares y no con su constructor. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye una homografía sobre la recta dada cuya matriz sea la dada. En general, este constructor no se usará directamente. <br>
Parámetros <br>
matriz: matriz(2, 2) - matriz asociada a la homografía <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto una recta con referencia {Infinity, 0; 1}) <br>
</p>
</div>
<div class='function'>
<h3>Función: aplicacion()</h3>
<p>
Devuelve esta homografía como una aplicacion_proyectiva. </p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta homografía. </p>
</div>
<div class='function'>
<h3>Función: recta()</h3>
<p>
Devuelve la recta sobre la que se aplica esta homografía. </p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia de la recta en la que está expresada esta homografía. </p>
</div>
<div class='function'>
<h3>Función: expresion_mobius()</h3>
<p>
Devuelve la homografía expresada como una transformación de M </p>
</div>
<div class='function'>
<h3>Función: ecuacion()</h3>
<p>
Devuelve la ecuación en theta y theta' de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta homografía del punto dado. <br>
Uso: h(x) ó h(p) (donde r es una homografia_recta, x un complejo/Infinity y p un punto). <br>
Implementación <br>
Dado un parámetro no homogéneo sustituye en la expresión de Möbius y devuelve el resultado. <br>
Dado un punto del espacio, primero calcula su coordenada en la recta y luego vuelve a llamar a este método. <br>
Parámetros <br>
x: complejo/Infinity/vector(n) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: autovalores()</h3>
<p>
Devuelve los autovalores de esta homografía. <br>
Implementación <br>
Ver autovalores() de aplicacion_proyectiva (aplicacion_proyectiva.sage). <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos_theta()</h3>
<p>
Devuelve los parámetros de los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Calcula los autovectores y deshomogeniza. <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos()</h3>
<p>
Devuelve los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Calcula los autovectores de la matriz asociada. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_identidad()</h3>
<p>
Determina si esta homografía es la identidad. <br>
Implementación <br>
Sustituye theta' por theta y resta un lado de la expresión de Möbius al otro para comparar con 0. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_elacion()</h3>
<p>
Determina si esta homografía es una elación, esto es si tiene un punto fijo doble. <br>
Implementación <br>
Calcula los puntos fijos y compara. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_involucion()</h3>
<p>
Determina si esta homografía es una involución, esto es si self^2 == self. <br>
Implementación <br>
Comprueba que la traza sea nula. <br>
</p>
</div>
<div class='function'>
<h3>Función: modulo()</h3>
<p>
Calcula el módulo de esta homografía, esto es el cociente de sus autovalores (en cualquier orden). <br>
</p>
</div>
<div class='function'>
<h3>Función: simplificar()</h3>
<p>
Devuelve esta misma homografía en una referencia adecuada de forma que su ecuación quede de la forma más simple posible. Para las involuciones no devuelve la forma general theta*theta' = 1. Para ello usar simplificar_involucion(). <br>
Implementación <br>
En función de los puntos fijos devuelve: <br>
infinitos -> ella misma (identidad) <br>
1         -> matriz (1, 1; 0, 1) con referencia el punto fijo y dos arbitrarios, multiplicada por lambda = delta/beta <br>
2         -> matriz (-beta/gamma, 0; 0, 1) con referencia los puntos fijos y uno arbitrario <br>
</p>
</div>
<div class='function'>
<h3>Función: simplificar_involucion()</h3>
<p>
Devuelve esta misma involución en una referencia adecuada de forma que su ecuación quede theta*theta' = 1. <br>
Implementación <br>
Asumiendo que esta homografía es una involución, los dos puntos fijos separan armónicamente cualquier par de la involución. Por tanto, basta con elegir cualquier punto y su imagen como Infinity y 0 y un punto fijo como 1. De esta forma, el otro punto fijo tendrá coordenada -1 y con ello obtenemos la ecuación deseada. <br>
</p>
</div>
<div class='function'>
<h3>Función: haz_ecuaciones_cuadraticas(a, b)</h3>
<p>
Devuelve el haz de ecuaciones cuadráticas generado por esta involución. <br>
Funciona tanto para puntos (vectores) como parámetros inhomogéneos de la recta. <br>
Implementación <br>
Asumiendo que esta homografía es una involución, calcula las imágenes de los puntos dados. Después, simplemente será necesario componerlos como dos ecuaciones cuyas soluciones sean cada par (theta_i, h(theta_i)). <br>
Parámetros <br>
a: complejo/Infinity/vector(n) - punto del primer par b: complejo/Infinity/vector(n) - punto del segundo par <br>
</p>
</div>
<div class='function'>
<h3>Función: __mul__(otra)</h3>
<p>
Operador *. Devuelve la composición de las homografías ((self o otra)(theta) = self(otra(theta))). <br>
Uso: h * k (h y k son homografías de una misma recta). <br>
Implementación <br>
Devuelve una nueva homografía cuya matriz sea el producto de las de ambas. <br>
Parámetros <br>
otra: homografia_recta - homografía con la que componer <br>
</p>
</div>
<div class='function'>
<h3>Función: __pow__(n)</h3>
<p>
Operador ^ (ó **). Devuelve el resultado de componer una homografía con sí misma n veces (^-1 devuelve la inversa). <br>
Uso h^n (ó h**n) (h es una homografía de la recta y n un entero). <br>
Implementación <br>
Devuelve una nueva homografía cuya matriz es la de esta elevada a n. <br>
Parámetros <br>
n: entero - exponente al que elevar <br>
</p>
</div>
</div>
</div>
</body>
</html>
