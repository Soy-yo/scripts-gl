<!doctype html>
<html>
<head>
<title>recta_proyectiva</title>
<meta charset='utf-8'><link rel='stylesheet' type='text/css' href='style.css'>
</head>
<body>
<a href='index.html'>Página principal</a><h1>recta_proyectiva</h1>
<p>
Este archivo proporciona diferentes funciones y clases sobre razones dobles y homografías de la recta. <br>
Suponemos que los puntos expresados con coordenada inhomogénea theta se obtiene mediante x/y. <br>
Autor: Pablo Sanz Sanz <br>
</p>
<div class='function'>
<h3>Función: razon_doble(a, b, c, d)</h3>
<p>
Calcula la razón doble {A, B; C, D}. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver razon_doble_puntos y razon_doble_theta, respectivamente). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble_puntos(p0, p1, p2, p3)</h3>
<p>
Calcula la razón doble ({P0, P1, P2, P3}) de los puntos alineados dados. <br>
Implementación <br>
Utiliza que la razón doble es invariante por proyecciones y la fórmula de la razón doble de los determinantes. Se elige una proyección que siga siendo una recta. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
p3: vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: razon_doble_theta(theta0, theta1, theta2, theta3)</h3>
<p>
Calcula la razón doble ({theta0, theta1, theta2, theta3}) de los puntos de la recta dados (con parámetro no homogéneo). <br>
Implementación <br>
Utiliza la razón doble definida para puntos tras homogeneizar las coordenadas. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
theta3: complejo/Infinity - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica(a, b, c, d)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {A, B; C, D} = -1. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver es_cuaterna_armonica_puntos y es_cuaterna_armonica_theta, respectivamente). <br>
NOTA. Puede ser que devuelva algo tipo (-1) = (-1); en tal caso habrá que comprobar que sea una igualdad realmente o usar bool(es_cuaterna_armonica(a, b, c, d)). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
d: complejo/Infinity/vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica_puntos(p0, p1, p2, p3)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {P0, P1, P2, P3} = -1. <br>
Implementación <br>
Devuelve {P0, P1; P2, P3} == -1 utilizando las funciones anteriores. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
p3: vector(n>1) - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: es_cuaterna_armonica_theta(theta0, theta1, theta2, theta3)</h3>
<p>
Determina si los puntos dados forman una cuaterna armónica, esto es, {theta0, theta1, theta2, theta3} = -1. <br>
Implementación <br>
Devuelve {theta0, theta1; theta2, theta3} == -1 utilizando las funciones anteriores. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
theta3: complejo/Infinity - cuarto punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico(a, b, c)</h3>
<p>
Devuelve el conjugado armónico de c respecto de a y b. Es válido tanto para puntos como para parámetros inhomogéneos de una recta proyectiva (ver conjugado_armonico_puntos y conjugado_armonico_theta, respectivamente). <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto de la razón doble <br>
b: complejo/Infinity/vector(n>1) - segundo punto de la razón doble <br>
c: complejo/Infinity/vector(n>1) - tercer punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico_puntos(p0, p1, p2)</h3>
<p>
Devuelve el conjugado armónico de p2 respecto de p0 y p1. <br>
Implementación <br>
Como la razón doble es la coordenada del cuarto punto respecto a la referencia {p0, p1; p2}, obtiene la recta que forman p0, p1 y p2 y devuelve el punto correspondiente a la coordenada theta == -1. <br>
Parámetros <br>
p0: vector(n>1) - primer punto de la razón doble <br>
p1: vector(n>1) - segundo punto de la razón doble <br>
p2: vector(n>1) - tercer punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: conjugado_armonico_theta(theta0, theta1, theta2)</h3>
<p>
Devuelve el conjugado armónico de theta2 respecto de theta0 y theta1. <br>
Implementación <br>
Resuelve la ecuación {theta0, theta1, theta2, theta} == -1 en theta utilizando las funciones anteriores. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto de la razón doble <br>
theta1: complejo/Infinity - segundo punto de la razón doble <br>
theta2: complejo/Infinity - tercer punto de la razón doble <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_recta(a, ap, b, bp, c = None, cp = None, recta = None, involucion = False)</h3>
<p>
Crea un objeto del tipo homografia_recta dados la recta y tres puntos y sus imágenes. Es válido tanto para puntos como parámetros inhomogéneos. <br>
Si se quiere crear una involución dados dos puntos y sus imágenes se pueden omitir los terceros puntos. La función se podría llamar de la siguiente forma: h = crear_homografia_recta(a, ap, b, bp, recta = r, involucion = True), si se especifica una recta r. <br>
Diferenciar de crear_aplicacion_proyectiva (aplicaciones.sage) en el orden de los argumentos y en que aquí no se piden listas. <br>
Implementación <br>
Si se dan puntos se obtiene primero su coordenada de la recta. Una vez obtenidas las coordenadas se usa crear_homografia_recta_theta. <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto a transformar <br>
ap: complejo/Infinity/vector(n>1) - imagen del primer punto <br>
b: complejo/Infinity/vector(n>1) - segundo punto a transformar <br>
bp: complejo/Infinity/vector(n>1) - imagen del segundo punto <br>
c: complejo/Infinity/vector(n>1) - tercer punto a transformar (no necesario si se va a crear una involución) <br>
cp: complejo/Infinity/vector(n>1) - imagen del tercer punto (no necesario si se va a crear una involución) <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto la recta que ponga homografia_recta por defecto (sólo válido para parámetros inhomogéneos)) <br>
involucion: booleano - True si se quiere crear una involución, False si no necesariamente (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_recta_theta(theta0, theta0p, theta1, theta1p, theta2 = None, theta2p = None, recta = None, involucion = False)</h3>
<p>
Crea un objeto del tipo homografia_recta dados la recta y tres puntos (con parámetros inhomogéneos) y sus imágenes. <br>
Si se quiere crear una involución dados dos puntos y sus imágenes se pueden omitir los terceros puntos. La función se podría llamar de la siguiente forma: h = crear_homografia_recta_theta(theta0, theta0p, theta1, theta1p, recta = r, involucion = True), si se especifica una recta r. <br>
Diferenciar de crear_aplicacion_proyectiva (aplicaciones.sage) en el orden de los argumentos y en que aquí no se piden listas. <br>
Implementación <br>
Se crea una primera homografía con ecuación theta' = (a*theta + b) / (c*theta + d), se sustituyen cada uno de los puntos dados y se resuelve el sistema. <br>
Parámetros <br>
theta0: complejo/Infinity - primer punto a transformar <br>
theta0p: complejo/Infinity - imagen del primer punto <br>
theta1: complejo/Infinity - segundo punto a transformar <br>
theta1p: complejo/Infinity - imagen del segundo punto <br>
theta2: complejo/Infinity - tercer punto a transformar (no necesario si se va a crear una involución) <br>
theta2p: complejo/Infinity - imagen del tercer punto (no necesario si se va a crear una involución) <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto la recta que ponga homografia_recta por defecto (sólo válido para parámetros inhomogéneos)) <br>
involucion: booleano - True si se quiere crear una involución, False si no necesariamente (False por defecto) <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_dos_rectas(a, ap, b, bp, c, cp, r_origen, r_destino)</h3>
<p>
Crea una homografía entre dos rectas que se cortan dados tres puntos de la recta origen y sus imágenes en la recta destino. Es válido tanto para puntos como parámetros inhomogéneos. <br>
Implementación <br>
Con las coordenadas inhomogéneas de cada punto se halla la homografía sobre una falsa recta {Infinity, 0; 1} que los trasnforma de la forma indicada. Simplemente se transforma la coordenada de una recta a la coordenada de la otra como si fuera una sola recta. <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - primer punto a transformar <br>
ap: complejo/Infinity/vector(n>1) - imagen del primer punto <br>
b: complejo/Infinity/vector(n>1) - segundo punto a transformar <br>
bp: complejo/Infinity/vector(n>1) - imagen del segundo punto <br>
c: complejo/Infinity/vector(n>1) - tercer punto a transformar <br>
cp: complejo/Infinity/vector(n>1) - imagen del tercer punto <br>
r_origen: recta_proyectiva - recta desde donde parte la homografía <br>
r_destino: recta_proyectiva - recta de llegada de la homografía <br>
</p>
</div>
<div class='function'>
<h3>Función: crear_homografia_dos_rectas_eje(a, ap, r_origen, r_destino, eje, extra = None)</h3>
<p>
Crea una homografía entre dos rectas que se cortan dados un punto y su imagen y el eje de la homografía (como subespacio). Es válido tanto para puntos como parámetros inhomogéneos. <br>
Implementación <br>
Obtiene el punto de corte del eje con cada una de las rectas. En caso de ser dos puntos distintos X e Y se tendrá que O' = Y y X' = O. Si son el mismo punto se utilizará un punto arbitrario extra B, que se puede especificar si se quiere, y se calculará su imagen: se traza una recta que pase por B y A' y cortará el eje en P; uniendo A con P se obtiene B' en la recta destino. El par de puntos será ese corte doble del eje con las rectas. Una vez obtenidos los puntos se usa crear_homografia_dos_rectas(). <br>
NOTA. Por simplicidad no se hacen comprobaciones sobre puntos coincidentes, pero se debe asegurar que ninguno de los puntos que se da como parámetros (tanto a, ap, como extra) coincida con la intersección (o entre ellos). En caso contrario es probable encontrarse con resultados extraños o incluso errores. <br>
Parámetros <br>
a: complejo/Infinity/vector(n>1) - punto a transformar <br>
ap: complejo/Infinity/vector(n>1) - imagen del punto <br>
r_origen: recta_proyectiva - recta desde donde parte la homografía <br>
r_destino: recta_proyectiva - recta de llegada de la homografía <br>
eje: subespacio - eje de la homografía, que debe cortar a las anteriores rectas (nótese que se pide un subespacio) <br>
extra: complejo/Infinity/vector(n>1) - punto extra de r_origen que se utilizará en caso de que el corte del eje con las rectas sea un único punto (por defecto la suma del corte y el punto a dado, como puntos) <br>
</p>
</div>
<div class='class'>
<h2>Clase: recta_proyectiva</h2>
<p>
Clase que representa una recta proyectiva para cualquier dimension ambiente. Sirve para cálculos de razones dobles o para homografías entre rectas. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Inicializa la recta dada la referencia {p0, p1; p2} que se quiere utilizar. <br>
Implementación <br>
Obtiene la matriz asociada a la referencia dada (esto es, multiplicando el vector asociado a p0 y p1 por un coeficiente de forma que a*p0 + b*p1 == p2) y construye el punto b*p1 + theta*a*p0. <br>
Parámetros <br>
p0: vector(n) - punto cuya coordenada será theta == Infinity <br>
p1: vector(n) - punto cuya coordenada será theta == 0 <br>
p2: vector(n) - punto cuya coordenada será theta == 1 (por defecto p0 + p1) <br>
</p>
</div>
<div class='function'>
<h3>Función: __getitem__(theta)</h3>
<p>
Devuelve el punto con coordenada theta. <br>
Uso: r[theta_0] (theta_0 es la coordenada del punto y r es una recta_proyectiva). <br>
Si se quiere un punto genérico de la recta, sustituir por una variable (ej: r[x] devuelve un punto dependiente de x). <br>
Parámetros <br>
theta: complejo/Infinity - coordenada del punto de la recta que se quiere obtener <br>
</p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia de esta recta proyectiva en forma de lista [Infinity, 0, 1]. </p>
</div>
<div class='function'>
<h3>Función: subespacio()</h3>
<p>
Devuelve esta recta proyectiva como objeto del tipo subespacio. </p>
</div>
<div class='function'>
<h3>Función: dimension_ambiente()</h3>
<p>
Devuelve la dimensión del espacio en que se encuentra esta recta. </p>
</div>
<div class='function'>
<h3>Función: coordenada(p)</h3>
<p>
Devuelve la coordenada no homogénea asociada al punto p dado. <br>
Implementación <br>
Resuelve la ecuación recta(theta) == alpha * p para theta. <br>
Parámetros <br>
p: vector(n) - punto de la recta del que se quiere conocer su coordenada <br>
</p>
</div>
<div class='function'>
<h3>Función: __eq__(otra)</h3>
<p>
Operador ==. Determina si dos rectas proyectivas son iguales. <br>
Uso: r == s (r y s son rectas proyectivas). <br>
Implementación <br>
Comrpueba que el subespacio sea el mismo. <br>
Parámetros <br>
otra: recta_proyectiva - recta a comprobar la igualdad <br>
</p>
</div>
<div class='function'>
<h3>Función: __contains__(punto)</h3>
<p>
Operador in. Determina si un punto está contenido en este subespacio o no. <br>
Uso: P in r (P es un punto y r una recta proyectiva). <br>
Implementación <br>
Comprueba que el punto pertenezca al subespacio asociado. <br>
Parámetros <br>
punto: vector(n) - punto que comprobar si pertenece a la recta <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: homografia_recta</h2>
<p>
Clase que representa una homografía de una recta en sí misma. En general, se crearán usando funciones auxiliares y no con su constructor. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye una homografía sobre la recta dada cuya matriz sea la dada. En general, este constructor no se usará directamente. <br>
Parámetros <br>
matriz: matriz(2, 2) - matriz asociada a la homografía <br>
recta: recta_proyectiva - recta sobre la que actúa la homografía (por defecto una recta con referencia {Infinity, 0; 1}) <br>
</p>
</div>
<div class='function'>
<h3>Función: aplicacion()</h3>
<p>
Devuelve esta homografía como una aplicacion_proyectiva. </p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta homografía. </p>
</div>
<div class='function'>
<h3>Función: recta()</h3>
<p>
Devuelve la recta sobre la que se aplica esta homografía. </p>
</div>
<div class='function'>
<h3>Función: referencia()</h3>
<p>
Devuelve la referencia de la recta en la que está expresada esta homografía. </p>
</div>
<div class='function'>
<h3>Función: expresion_mobius()</h3>
<p>
Devuelve la homografía expresada como una transformación de Möbius. </p>
</div>
<div class='function'>
<h3>Función: ecuacion()</h3>
<p>
Devuelve la ecuación en theta y theta' de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta homografía del punto dado. <br>
Uso: h(x) ó h(p) (donde h es una homografia_recta, x un complejo/Infinity y p un punto). <br>
Implementación <br>
Dado un parámetro no homogéneo sustituye en la expresión de Möbius y devuelve el resultado. <br>
Dado un punto del espacio, primero calcula su coordenada en la recta y luego vuelve a llamar a este método. <br>
Parámetros <br>
x: complejo/Infinity/vector(n) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: autovalores()</h3>
<p>
Devuelve los autovalores de esta homografía. <br>
Implementación <br>
Ver autovalores() de aplicacion_proyectiva (aplicacion_proyectiva.sage). <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos_theta()</h3>
<p>
Devuelve los parámetros de los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Calcula los autovectores y deshomogeniza. <br>
</p>
</div>
<div class='function'>
<h3>Función: puntos_fijos()</h3>
<p>
Devuelve los puntos fijos de esta homografía. Devuelve una lista vacía en caso de que sea la identidad. <br>
Implementación <br>
Calcula los autovectores de la matriz asociada. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_identidad()</h3>
<p>
Determina si esta homografía es la identidad. <br>
Implementación <br>
Sustituye theta' por theta y resta un lado de la expresión de Möbius al otro para comparar con 0. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_elacion()</h3>
<p>
Determina si esta homografía es una elación, esto es si tiene un punto fijo doble. <br>
Implementación <br>
Calcula los puntos fijos y compara. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_involucion()</h3>
<p>
Determina si esta homografía es una involución, esto es si self^2 == self. <br>
Implementación <br>
Comprueba que la traza sea nula. <br>
</p>
</div>
<div class='function'>
<h3>Función: modulo()</h3>
<p>
Calcula el módulo de esta homografía, esto es el cociente de sus autovalores (en cualquier orden). <br>
</p>
</div>
<div class='function'>
<h3>Función: simplificar()</h3>
<p>
Devuelve esta misma homografía en una referencia adecuada de forma que su ecuación quede de la forma más simple posible. Para las involuciones no devuelve la forma general theta*theta' = 1. Para ello usar simplificar_involucion(). <br>
Implementación <br>
En función de los puntos fijos devuelve: <br>
infinitos -> ella misma (identidad) <br>
1         -> matriz (1, 1; 0, 1) con referencia el punto fijo y dos arbitrarios, multiplicada por lambda = delta/beta <br>
2         -> matriz (-beta/gamma, 0; 0, 1) con referencia los puntos fijos y uno arbitrario <br>
</p>
</div>
<div class='function'>
<h3>Función: simplificar_involucion()</h3>
<p>
Devuelve esta misma involución en una referencia adecuada de forma que su ecuación quede theta*theta' = 1. <br>
Implementación <br>
Asumiendo que esta homografía es una involución, los dos puntos fijos separan armónicamente cualquier par de la involución. Por tanto, basta con elegir cualquier punto y su imagen como Infinity y 0 y un punto fijo como 1. De esta forma, el otro punto fijo tendrá coordenada -1 y con ello obtenemos la ecuación deseada. <br>
</p>
</div>
<div class='function'>
<h3>Función: haz_ecuaciones_cuadraticas(a, b)</h3>
<p>
Devuelve el haz de ecuaciones cuadráticas generado por esta involución. <br>
Funciona tanto para puntos (vectores) como parámetros inhomogéneos de la recta. <br>
Implementación <br>
Asumiendo que esta homografía es una involución, calcula las imágenes de los puntos dados. Después, simplemente será necesario componerlos como dos ecuaciones cuyas soluciones sean cada par (theta_i, h(theta_i)). <br>
Parámetros <br>
a: complejo/Infinity/vector(n) - punto del primer par b: complejo/Infinity/vector(n) - punto del segundo par <br>
</p>
</div>
<div class='function'>
<h3>Función: __mul__(otra)</h3>
<p>
Operador *. Devuelve la composición de las homografías ((self o otra)(theta) = self(otra(theta))). <br>
Uso: h * k (h y k son homografías de una misma recta). <br>
Implementación <br>
Devuelve una nueva homografía cuya matriz sea el producto de las de ambas. <br>
Parámetros <br>
otra: homografia_recta - homografía con la que componer <br>
</p>
</div>
<div class='function'>
<h3>Función: __pow__(n)</h3>
<p>
Operador ^ (ó **). Devuelve el resultado de componer una homografía con sí misma n veces (^-1 devuelve la inversa). <br>
Uso h^n (ó h**n) (h es una homografía de la recta y n un entero). <br>
Implementación <br>
Devuelve una nueva homografía cuya matriz es la de esta elevada a n. <br>
Parámetros <br>
n: entero - exponente al que elevar <br>
</p>
</div>
</div>
</div>
<div class='class'>
<h2>Clase: homografia_dos_rectas</h2>
<p>
Clase que representa una homografía entre dos rectas distintas. En general, se creará utilizando funciones auxiliares. <br>
Se representa mediante una falsa homografía de una recta en sí misma, que para lo único que servirá será para aprovechar sus métodos. <br>
</p>
<div class='methods'>
<div class='function'>
<h3>Constructor</h3>
<p>
Construye una homografía entre dos rectas dadas la homografía de una falsa recta en sí misma y las dos rectas. <br>
En general, no se usará este constructor directamente, sino que se creará a partir de funciones creadoras externas. <br>
Parámetros <br>
homografia: homografia_recta - homografía que convierte la coordenada inhomogénea de un punto de la primera recta en la de su imagen <br>
recta1: recta_proyectiva - recta origen de la homografía <br>
recta2: recta_proyectiva - recta destino de la homografía <br>
</p>
</div>
<div class='function'>
<h3>Función: aplicacion()</h3>
<p>
Devuelve esta homografía como una aplicacion_proyectiva. Nótese que así dejará de estar restringida a las rectas origen y destino. </p>
</div>
<div class='function'>
<h3>Función: matriz_asociada()</h3>
<p>
Devuelve la matriz asociada a esta homografía. </p>
</div>
<div class='function'>
<h3>Función: interseccion()</h3>
<p>
Devuelve el punto de interseccion de las rectas de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: recta_origen()</h3>
<p>
Devuelve la recta de partida de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: referencia_origen()</h3>
<p>
Devuelve la referencia en la que está expresada la recta origen. </p>
</div>
<div class='function'>
<h3>Función: recta_destino()</h3>
<p>
Devuelve la recta de destino de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: referencia_destino()</h3>
<p>
Devuelve la referencia en la que está expresada la recta destino. </p>
</div>
<div class='function'>
<h3>Función: expresion_mobius()</h3>
<p>
Devuelve la homografía expresada como una transformación de Möbius. </p>
</div>
<div class='function'>
<h3>Función: ecuacion()</h3>
<p>
Devuelve la ecuación en theta y theta' de esta homografía. </p>
</div>
<div class='function'>
<h3>Función: __call__(x)</h3>
<p>
Calcula la imagen mediante esta homografía del punto dado. <br>
Uso: h(x) ó h(p) (donde r es una homografia_recta, x un complejo/Infinity y p un punto). <br>
Implementación <br>
Calcula el parámetro no homogéneo asociado a la imagen del punto dado mediante la falsa homografía. <br>
Si se ha dado un parámetro devolverá el parámetro y si se ha dado un punto devolverá el punto. <br>
Parámetros <br>
x: complejo/Infinity/vector(n) - punto del que se quiere calcular su imagen <br>
</p>
</div>
<div class='function'>
<h3>Función: eje(recta = False, a = Infinity, b = 0, c = 1)</h3>
<p>
Calcula el eje de esta homografía utilizando el teorema del eje. Se puede pedir que se devuelva en forma de recta_proyectiva en vez de como subespacio (por defecto). En tal caso, se pueden indicar los puntos que se quiere utilizar para hallar el eje y de los cortes generados se obtendrá la referencia de dicha recta. El primer punto es el generado por ab, el ssegundo ac y el tercero bc. Importante no repetir si se indican los puntos y evitar que uno de ellos sea la intersección (de momento da error). <br>
Implementación <br>
Se escogen los puntos indicados o tres puntos arbitrarios P, Q, R. Se calculan sus imágenes P', Q', R' y se unen las de distinto nombre. La unión de las intersecciones resultará en el eje. <br>
Parámetros <br>
recta: booleano - determina si se quiere obtener un objeto del tipo recta_proyectiva como resultado en vez de un subespacio (False por defecto) <br>
a: complejo/Infinity - primer punto para obtener el eje (por defecto Infinity) <br>
b: complejo/Infinity - segundo punto para obtener el eje (por defecto 0) <br>
c: complejo/Infinity - tercer punto para obtener el eje (por defecto 1) <br>
</p>
</div>
<div class='function'>
<h3>Función: eje2()</h3>
<p>
Calcula el eje de esta homografía si no es una perspectividad. <br>
Implementación <br>
Devuelve la recta que une h(O) con h^-1(O), donde O es el punto de intersección de las rectas y h es esta homografía. <br>
</p>
</div>
<div class='function'>
<h3>Función: es_perspectividad()</h3>
<p>
Determina si esta homografía es una perspectividad. <br>
Implementación <br>
Comprueba que la intersección de las dos rectas sea un punto fijo, esto es, h(O) = a*O, donde h es esta homografía, O el punto de intersección y a un parámetro cualquiera. <br>
</p>
</div>
<div class='function'>
<h3>Función: centro()</h3>
<p>
Calcula el punto centro de esta perspectividad. <br>
Implementación <br>
Calcula el corte de las rectas que forman dos pares arbitrarios que no coincidan con la intersección. <br>
</p>
</div>
<div class='function'>
<h3>Función: inversa()</h3>
<p>
Devuelve la inversa de esta homografía que va de la recta de destino a la recta origen. <br>
Implementación <br>
Devuelve una nueva homografia_dos_rectas cuya falsa homografía sea la inversa de la actual y con las rectas intercambiadas. <br>
</p>
</div>
<div class='function'>
<h3>Función: __mul__(otra)</h3>
<p>
Operador *. Devuelve la composición de las homografías ((self o otra)(theta) = self(otra(theta))). Se debe cumplir que las tres rectas implicadas se corten en un mismo punto o que sólo hay dos. <br>
Uso: h * k (h y k son homografías tal que el destino de k es el origen de h en la misma referencia). <br>
Implementación <br>
Devuelve la composición de la falsa homografía de la otra con esta. <br>
NOTA. Por simplicidad NO se comprueba que las referencias de las rectas que tienen que ser iguales coincidan (aunque debería). Se debe asegurar de todas formas que la referencia de ambas rectas sea la misma o si no el resultado no será válido. <br>
Parámetros <br>
otra: homografia_dos_rectas - homografía con la que componer <br>
</p>
</div>
<div class='function'>
<h3>Función: __pow__(n)</h3>
<p>
Operador ^ (ó **). Sólo aplicable para n = -1. Usar inversa() mejor. Devuelve la inversa de esta homografía. <br>
Uso h^-1 (ó h**-1) (h es una homografía entre dos rectas y n un entero). <br>
Implementación <br>
Ver inversa. <br>
Parámetros <br>
n: -1 - exponente al que elevar <br>
</p>
</div>
</div>
</div>
<div class='function'>
<h3>Función: es_parametro(x)</h3>
<p>
Función auxiliar que determina si el parámetro recibido es un punto (tipo vector) o un parámetro inhomogéneo de una recta proyectiva. <br>
Parámetros <br>
x: complejo/Infinity/variable/vector(n>1) - elemento a considerar <br>
</p>
</div>
<div class='function'>
<h3>Función: es_infinito(x)</h3>
<p>
Función auxiliar que determina si el parámetro recibido es infinito o no. Sólo devuelve True para +/-Infinity. <br>
Parámetros <br>
x: complejo/Infinity/variable/vector(n) - elemento a considerar <br>
</p>
</div>
</body>
</html>
